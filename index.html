<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÌÇ§Î≥¥Îìú Î∂ÑÏàò ÎÜÄÏù¥ÌÑ∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            cursor: pointer;
            background: linear-gradient(to bottom, 
                #87CEEB 0%, 
                #98D8E8 20%, 
                #B0E0E6 40%, 
                #FFE4B5 60%, 
                #FFDAB9 80%, 
                #FFB6C1 100%);
        }
        
        #canvas {
            display: block;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 24px;
            color: #333;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 3px solid #FFD700;
            animation: bounce 2s infinite;
            z-index: 100;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }
        
        .key-display {
            position: absolute;
            font-size: 60px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            animation: keyPop 0.5s ease-out;
            pointer-events: none;
            z-index: 50;
        }
        
        @keyframes keyPop {
            0% { transform: scale(0) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.5) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="instructions">üéπ ÏïÑÎ¨¥ ÌÇ§ÎÇò ÎàåÎü¨Î≥¥ÏÑ∏Ïöî! üåä</div>
    <canvas id="canvas"></canvas>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script>
        // Scene setup with colorful fog
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xB0E0E6, 20, 120);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 40);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('canvas'),
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x87CEEB, 0);
        
        // Cartoon-style lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);
        
        // Natural hexagonal ground
        const groundSize = 60;
        const hexSize = 3; // Size of each hexagon
        const groundGroup = new THREE.Group();
        
        // Create a natural color palette
        const tileColors = [0x6B8E23, 0x556B2F, 0x8FBC8F, 0x2E8B57, 0x3CB371];

        const hexHeight = Math.sqrt(3) * hexSize;
        const hexWidth = 2 * hexSize;

        for (let q = -15; q <= 15; q++) {
            for (let r = -15; r <= 15; r++) {
                const x = hexWidth * 0.75 * q;
                const z = hexHeight * (r + q / 2);

                // Ensure tiles are within a circular radius for a more organic shape
                if (Math.sqrt(x*x + z*z) > groundSize / 2) continue;

                const hexGeometry = new THREE.CylinderGeometry(hexSize, hexSize, 0.3, 6);
                const tileMaterial = new THREE.MeshToonMaterial({
                    color: tileColors[Math.floor(Math.random() * tileColors.length)]
                });

                const tile = new THREE.Mesh(hexGeometry, tileMaterial);

                // Rotate to make it a flat-topped hexagon
                tile.rotation.y = Math.PI / 2;

                tile.position.set(x, -2, z);
                tile.receiveShadow = true;
                tile.castShadow = true;
                groundGroup.add(tile);
            }
        }
        scene.add(groundGroup);
        
        // Add decorative flowers randomly on the ground
        for (let i = 0; i < 20; i++) {
            const flowerGroup = new THREE.Group();
            
            // Stem
            const stemGeometry = new THREE.CylinderGeometry(0.05, 0.08, 1, 6);
            const stemMaterial = new THREE.MeshToonMaterial({ color: 0x228B22 });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = -1.5;
            flowerGroup.add(stem);
            
            // Flower petals
            const petalColor = [0xFF69B4, 0xFFB6C1, 0xFFA07A, 0xFF1493, 0xFFFFE0][Math.floor(Math.random() * 5)];
            for (let j = 0; j < 5; j++) {
                const petalAngle = (j / 5) * Math.PI * 2;
                const petalGeometry = new THREE.SphereGeometry(0.2, 6, 6);
                const petalMaterial = new THREE.MeshToonMaterial({ color: petalColor });
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                petal.position.set(
                    Math.cos(petalAngle) * 0.3,
                    -1,
                    Math.sin(petalAngle) * 0.3
                );
                petal.scale.set(1.2, 0.8, 0.8);
                flowerGroup.add(petal);
            }
            
            // Center
            const centerGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const centerMaterial = new THREE.MeshToonMaterial({ color: 0xFFD700 });
            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            center.position.y = -1;
            flowerGroup.add(center);
            
            flowerGroup.position.set(
                (Math.random() - 0.5) * 50,
                0,
                (Math.random() - 0.5) * 50
            );
            flowerGroup.scale.setScalar(Math.random() * 0.5 + 0.8);
            scene.add(flowerGroup);
        }
        
        // Add clouds
        const clouds = [];
        for (let i = 0; i < 15; i++) {
            const cloudGroup = new THREE.Group();
            
            // Create fluffy cloud with multiple spheres
            for (let j = 0; j < 5; j++) {
                const cloudPartGeometry = new THREE.SphereGeometry(
                    Math.random() * 2 + 1.5, 
                    8, 
                    8
                );
                const cloudMaterial = new THREE.MeshToonMaterial({ 
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.9
                });
                const cloudPart = new THREE.Mesh(cloudPartGeometry, cloudMaterial);
                cloudPart.position.set(
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 2
                );
                cloudGroup.add(cloudPart);
            }
            
            cloudGroup.position.set(
                (Math.random() - 0.5) * 80,
                Math.random() * 15 + 20,
                (Math.random() - 0.5) * 80
            );
            cloudGroup.scale.setScalar(Math.random() * 0.5 + 0.8);
            clouds.push(cloudGroup);
            scene.add(cloudGroup);
        }
        
        // Add rainbow arch
        const rainbowColors = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3];
        const rainbowGroup = new THREE.Group();
        
        rainbowColors.forEach((color, i) => {
            const radius = 25 - i * 0.7;
            const tubeRadius = 0.5;
            
            // Create rainbow using torus geometry (half donut shape)
            const torusGeometry = new THREE.TorusGeometry(radius, tubeRadius, 8, 30, Math.PI);
            const torusMaterial = new THREE.MeshToonMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.7
            });
            const rainbow = new THREE.Mesh(torusGeometry, torusMaterial);
            rainbow.rotation.z = Math.PI;
            rainbowGroup.add(rainbow);
        });
        
        rainbowGroup.position.set(0, 10, -30);
        rainbowGroup.rotation.y = Math.PI * 0.2;
        rainbowGroup.name = 'rainbow';
        scene.add(rainbowGroup);
        
        // Add a cartoon sun
        const sunGroup = new THREE.Group();
        
        const sunGeometry = new THREE.SphereGeometry(3, 16, 16);
        const sunMaterial = new THREE.MeshToonMaterial({ 
            color: 0xFFD700,
            emissive: 0xFFA500,
            emissiveIntensity: 0.7
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sunGroup.add(sun);
        
        // Sun rays
        for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2;
            const rayGeometry = new THREE.ConeGeometry(0.5, 3, 4);
            const rayMaterial = new THREE.MeshToonMaterial({ 
                color: 0xFFD700,
                emissive: 0xFFD700,
                emissiveIntensity: 0.5
            });
            const ray = new THREE.Mesh(rayGeometry, rayMaterial);
            ray.position.set(Math.cos(angle) * 4, Math.sin(angle) * 4, 0);
            ray.rotation.z = angle + Math.PI / 2;
            sunGroup.add(ray);
        }
        
        sunGroup.position.set(-25, 30, -20);
        sunGroup.name = 'sun';
        scene.add(sunGroup);
        
        // Multiple fountain bases
        const bases = [];
        const basePositions = [
            {x: 0, z: 0},
            {x: -15, z: -10},
            {x: 15, z: -10},
            {x: -15, z: 10},
            {x: 15, z: 10},
            {x: -25, z: 0},
            {x: 25, z: 0},
            {x: 0, z: -15},
            {x: 0, z: 15}
        ];
        
        basePositions.forEach(pos => {
            const baseGeometry = new THREE.CylinderGeometry(3, 4, 1.5, 8);
            const baseMaterial = new THREE.MeshToonMaterial({ 
                color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5)
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(pos.x, -1, pos.z);
            base.castShadow = true;
            base.receiveShadow = true;
            scene.add(base);
            bases.push(base);
            
            const poolGeometry = new THREE.CylinderGeometry(2.5, 3.5, 1.2, 8);
            const poolMaterial = new THREE.MeshToonMaterial({ 
                color: 0x00CED1,
                transparent: true,
                opacity: 0.6
            });
            const pool = new THREE.Mesh(poolGeometry, poolMaterial);
            pool.position.set(pos.x, -0.5, pos.z);
            scene.add(pool);
        });
        
        // Particle system for water
        class WaterJet {
            constructor(x, z, color) {
                this.particles = [];
                this.origin = new THREE.Vector3(x, 0, z);
                this.color = color;
                this.isActive = true;
                
                for (let i = 0; i < 50; i++) {
                    const geometry = new THREE.SphereGeometry(Math.random() * 0.3 + 0.1, 8, 8);
                    const material = new THREE.MeshToonMaterial({ 
                        color: color,
                        transparent: true,
                        opacity: 0.8
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    particle.castShadow = true;
                    
                    // Stagger the launch time for more natural effect
                    particle.delay = i * 0.008;
                    particle.launched = false;
                    
                    // Lower initial velocity for more falling emphasis
                    const angle = Math.random() * Math.PI * 2;
                    const spread = Math.random() * 0.5 + 0.1;
                    particle.velocity = new THREE.Vector3(
                        Math.cos(angle) * spread,
                        Math.random() * 0.8 + 0.8,  // Slightly higher upward velocity
                        Math.sin(angle) * spread
                    );
                    particle.position.copy(this.origin);
                    particle.life = 1.0;
                    particle.visible = false;
                    
                    this.particles.push(particle);
                    scene.add(particle);
                }
                this.elapsedTime = 0;
            }
            
            update(deltaTime = 0.016) {
                if (!this.isActive) return false;
                
                this.elapsedTime += deltaTime;
                let activeParticles = 0;
                
                this.particles.forEach(particle => {
                    // Launch particles with delay
                    if (!particle.launched && this.elapsedTime > particle.delay) {
                        particle.launched = true;
                        particle.visible = true;
                    }
                    
                    if (particle.launched && particle.life > 0) {
                        particle.position.add(particle.velocity);
                        
                        // Stronger gravity for more dramatic falling
                        particle.velocity.y -= 0.08; // Increased gravity
                        
                        // Add slight air resistance for realistic motion
                        particle.velocity.x *= 0.99;
                        particle.velocity.z *= 0.99;
                        
                        particle.life -= 0.015; // Slower life decay for longer fall
                        
                        if (particle.life > 0) {
                            particle.material.opacity = particle.life * 0.8;
                            
                            // Scale particles down as they fall
                            const scale = particle.life * (1 + Math.abs(particle.velocity.y) * 0.1);
                            particle.scale.setScalar(scale);
                            activeParticles++;
                        } else {
                            particle.visible = false;
                        }
                        
                        // Hide particle if it falls too low
                        if (particle.position.y < -2) {
                            particle.life = 0;
                            particle.visible = false;
                        }
                    }
                });
                
                // Return true if still active, false if all particles are done
                if (activeParticles === 0 && this.elapsedTime > 1.0) {
                    this.isActive = false;
                    return false;
                }
                return true;
            }
            
            remove() {
                this.particles.forEach(particle => {
                    scene.remove(particle);
                });
            }
        }
        
        const activeJets = [];
        
        // Sound setup
        const synth = new Tone.PolySynth(Tone.Synth, {
            oscillator: {
                type: "sine"
            },
            envelope: {
                attack: 0.02,
                decay: 0.1,
                sustain: 0.3,
                release: 1
            }
        }).toDestination();
        
        // Note mapping for keyboard
        const notes = [
            'C4', 'C#4', 'D4', 'D#4', 'E4', 'F4', 'F#4', 'G4', 'G#4', 'A4', 'A#4', 'B4',
            'C5', 'C#5', 'D5', 'D#5', 'E5', 'F5', 'F#5', 'G5', 'G#5', 'A5', 'A#5', 'B5',
            'C6'
        ];
        
        // Color palette
        const colors = [
            0xFF69B4, 0x00CED1, 0xFFD700, 0xFF6347, 0x9370DB,
            0x00FA9A, 0xFF1493, 0x1E90FF, 0xFFA500, 0x32CD32
        ];
        
        // Key to color mapping function
        function getColorForKey(event) {
            // Use key string for consistent mapping
            const keyString = event.key || String.fromCharCode(event.keyCode);
            let hash = 0;
            for (let i = 0; i < keyString.length; i++) {
                hash = ((hash << 5) - hash) + keyString.charCodeAt(i);
                hash = hash & hash; // Convert to 32-bit integer
            }
            const colorIndex = Math.abs(hash) % colors.length;
            return colors[colorIndex];
        }
        
        // Decorative elements
        function createStar(x, y, z) {
            const starGroup = new THREE.Group();
            
            // Create a 5-pointed star shape
            const starShape = new THREE.Shape();
            const outerRadius = 0.8;
            const innerRadius = 0.3;
            const points = 5;
            
            for (let i = 0; i < points * 2; i++) {
                const angle = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const px = Math.cos(angle) * radius;
                const py = Math.sin(angle) * radius;
                
                if (i === 0) {
                    starShape.moveTo(px, py);
                } else {
                    starShape.lineTo(px, py);
                }
            }
            starShape.closePath();
            
            // Extrude the star shape to give it depth
            const extrudeSettings = {
                depth: 0.2,
                bevelEnabled: true,
                bevelSegments: 2,
                steps: 1,
                bevelSize: 0.05,
                bevelThickness: 0.05
            };
            
            const starGeometry = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
            const starMaterial = new THREE.MeshToonMaterial({ 
                color: 0xFFD700,
                emissive: 0xFFA500,
                emissiveIntensity: 0.5
            });
            
            const starMesh = new THREE.Mesh(starGeometry, starMaterial);
            starMesh.castShadow = true;
            starMesh.receiveShadow = true;
            
            // Add a glowing sphere in the center
            const glowGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                transparent: true,
                opacity: 0.8
            });
            const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
            glowSphere.position.z = 0.1;
            
            starGroup.add(starMesh);
            starGroup.add(glowSphere);
            starGroup.position.set(x, y, z);
            
            // Random initial rotation for variety
            starGroup.rotation.x = Math.random() * Math.PI;
            starGroup.rotation.y = Math.random() * Math.PI;
            starGroup.rotation.z = Math.random() * Math.PI;
            
            return starGroup;
        }
        
        // Add floating stars with sparkle effect
        const stars = [];
        for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2;
            const radius = 20 + Math.random() * 15;
            const star = createStar(
                Math.cos(angle) * radius,
                Math.random() * 15 + 10,
                Math.sin(angle) * radius
            );
            stars.push(star);
            scene.add(star);
            
            // Add sparkle particles around each star
            const sparkleCount = 5;
            star.sparkles = [];
            for (let j = 0; j < sparkleCount; j++) {
                const sparkleGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                const sparkleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: Math.random() * 0.5 + 0.5
                });
                const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                sparkle.position.set(
                    star.position.x + (Math.random() - 0.5) * 2,
                    star.position.y + (Math.random() - 0.5) * 2,
                    star.position.z + (Math.random() - 0.5) * 2
                );
                sparkle.basePosition = sparkle.position.clone();
                star.sparkles.push(sparkle);
                scene.add(sparkle);
            }
        }
        
        // Keyboard event handler
        document.addEventListener('keydown', (event) => {
            event.preventDefault();
            
            // Hide instructions after first key press
            const instructions = document.getElementById('instructions');
            if (instructions) {
                instructions.style.display = 'none';
            }
            
            // Play sound
            const noteIndex = event.keyCode % notes.length;
            const note = notes[noteIndex];
            synth.triggerAttackRelease(note, "8n");
            
            // Create water jet across the entire screen
            // Map screen coordinates to 3D world coordinates
            const spreadX = (Math.random() - 0.5) * 40;  // Wider X spread
            const spreadZ = (Math.random() - 0.5) * 30;  // Wider Z spread
            const x = spreadX;
            const z = spreadZ;
            const color = getColorForKey(event);  // Fixed color based on key
            
            const jet = new WaterJet(x, z, color);
            activeJets.push(jet);
            
            // Display pressed key with matching color
            const keyDisplay = document.createElement('div');
            keyDisplay.className = 'key-display';
            keyDisplay.textContent = event.key.toUpperCase();
            keyDisplay.style.left = Math.random() * (window.innerWidth - 100) + 'px';
            keyDisplay.style.top = Math.random() * (window.innerHeight - 100) + 'px';
            keyDisplay.style.color = `#${color.toString(16).padStart(6, '0')}`;
            document.body.appendChild(keyDisplay);
            
            setTimeout(() => {
                keyDisplay.remove();
            }, 500);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update water jets and remove inactive ones
            for (let i = activeJets.length - 1; i >= 0; i--) {
                const jet = activeJets[i];
                const stillActive = jet.update();
                if (!stillActive) {
                    jet.remove();
                    activeJets.splice(i, 1);
                }
            }
            
            // Animate clouds
            clouds.forEach((cloud, i) => {
                cloud.position.x += Math.sin(Date.now() * 0.0001 + i) * 0.05;
                cloud.position.z += Math.cos(Date.now() * 0.0001 + i) * 0.03;
                cloud.position.y += Math.sin(Date.now() * 0.0005 + i * 0.5) * 0.02;
            });
            
            // Animate sun
            const sunGroup = scene.getObjectByName('sun');
            if (sunGroup) {
                sunGroup.rotation.z += 0.005;
                sunGroup.position.y = 30 + Math.sin(Date.now() * 0.001) * 2;
            }
            
            // Animate rainbow
            const rainbowGroup = scene.getObjectByName('rainbow');
            if (rainbowGroup) {
                rainbowGroup.position.y = 10 + Math.sin(Date.now() * 0.0008) * 1;
                rainbowGroup.rotation.y = Math.sin(Date.now() * 0.0003) * 0.2 + Math.PI * 0.2;
            }
            
            // Rotate and animate stars
            stars.forEach((star, i) => {
                // Rotate the star on multiple axes for a twinkling effect
                star.rotation.y += 0.02;
                star.rotation.z += 0.01;
                star.rotation.x += 0.005;
                
                // Floating animation
                star.position.y += Math.sin(Date.now() * 0.001 + i * 0.5) * 0.02;
                
                // Pulse effect
                const scale = 1 + Math.sin(Date.now() * 0.003 + i) * 0.1;
                star.scale.setScalar(scale);
                
                // Animate sparkles around the star
                if (star.sparkles) {
                    star.sparkles.forEach((sparkle, j) => {
                        const time = Date.now() * 0.002 + j;
                        sparkle.position.x = sparkle.basePosition.x + Math.sin(time) * 0.3;
                        sparkle.position.y = sparkle.basePosition.y + Math.cos(time * 1.3) * 0.3;
                        sparkle.position.z = sparkle.basePosition.z + Math.sin(time * 0.7) * 0.3;
                        sparkle.material.opacity = 0.3 + Math.sin(time * 2) * 0.3;
                    });
                }
            });
            
            // Subtle camera movement
            camera.position.x = Math.sin(Date.now() * 0.0005) * 5;
            camera.position.z = 40 + Math.cos(Date.now() * 0.0003) * 5;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start animation
        animate();
        
        // Initialize audio context on first interaction
        document.addEventListener('click', async () => {
            await Tone.start();
        }, { once: true });
    </script>
</body>
</html>